package com.codemap.core.routine.service;

import com.codemap.core.routine.domain.CodingTestReview;
import com.codemap.core.routine.domain.CodingTestReviewHistory;
import com.codemap.core.routine.domain.DailyRoutine;
import com.codemap.core.routine.domain.InterviewReview;
import com.codemap.core.routine.domain.InterviewReviewHistory;
import com.codemap.core.routine.domain.PomodoroSession;
import com.codemap.core.routine.domain.PomodoroSessionHistory;
import com.codemap.core.routine.domain.RoutineHistory;
import com.codemap.core.routine.dto.CodingTestReviewHistoryDto;
import com.codemap.core.routine.dto.InterviewReviewHistoryDto;
import com.codemap.core.routine.dto.PomodoroSessionHistoryDto;
import com.codemap.core.routine.dto.RoutineHistoryDto;
import com.codemap.core.routine.repository.CodingTestReviewHistoryRepository;
import com.codemap.core.routine.repository.CodingTestReviewRepository;
import com.codemap.core.routine.repository.DailyRoutineRepository;
import com.codemap.core.routine.repository.InterviewReviewHistoryRepository;
import com.codemap.core.routine.repository.InterviewReviewRepository;
import com.codemap.core.routine.repository.PomodoroSessionHistoryRepository;
import com.codemap.core.routine.repository.PomodoroSessionRepository;
import com.codemap.core.routine.repository.RoutineHistoryRepository;
import com.codemap.core.user.domain.User;
import com.codemap.core.user.service.UserService;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoutineHistoryService {

    private final RoutineHistoryRepository routineHistoryRepository;
    private final DailyRoutineRepository dailyRoutineRepository;
    private final PomodoroSessionRepository pomodoroSessionRepository;
    private final PomodoroSessionHistoryRepository pomodoroSessionHistoryRepository;
    private final CodingTestReviewHistoryRepository codingTestReviewHistoryRepository;
    private final InterviewReviewHistoryRepository interviewReviewHistoryRepository;

    private final CodingTestReviewRepository codingTestReviewRepository;
    private final InterviewReviewRepository interviewReviewRepository;

    private final UserService userService;

    // ÌäπÏ†ï ÎÇ†ÏßúÏùò ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
    public List<RoutineHistoryDto> getHistoryByDate(Long userId, LocalDate date) {
        User user = userService.getUserById(userId);
        List<RoutineHistory> histories = routineHistoryRepository.findByUserAndRoutineDateOrderByCreatedAtDesc(
            user, date);

        return histories.stream()
            .map(RoutineHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    public List<CodingTestReviewHistoryDto> getCodingTestReviewHistoryByDate(Long userId,
        LocalDate date) {
        User user = userService.getUserById(userId);
        List<CodingTestReviewHistory> histories = codingTestReviewHistoryRepository
            .findByUserAndRoutineDateOrderByCreatedAtDesc(user, date);

        return histories.stream()
            .map(CodingTestReviewHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    public List<InterviewReviewHistoryDto> getInterviewReviewHistoryByDate(Long userId,
        LocalDate date) {
        User user = userService.getUserById(userId);
        List<InterviewReviewHistory> histories = interviewReviewHistoryRepository
            .findByUserAndRoutineDateOrderByCreatedAtDesc(user, date);

        return histories.stream()
            .map(InterviewReviewHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    public List<CodingTestReviewHistoryDto> getCodingTestReviewHistoryByRoutineId(Long routineId,
        LocalDate date) {
        List<CodingTestReviewHistory> histories = codingTestReviewHistoryRepository
            .findByOriginalRoutineIdAndRoutineDate(routineId, date);

        return histories.stream()
            .map(CodingTestReviewHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    public List<InterviewReviewHistoryDto> getInterviewReviewHistoryByRoutineId(Long routineId,
        LocalDate date) {
        List<InterviewReviewHistory> histories = interviewReviewHistoryRepository
            .findByOriginalRoutineIdAndRoutineDate(routineId, date);

        return histories.stream()
            .map(InterviewReviewHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    // Ìè¨Î™®ÎèÑÎ°ú ÏÑ∏ÏÖò ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå Î©îÏÑúÎìúÎì§ Ï∂îÍ∞Ä
    public List<PomodoroSessionHistoryDto> getPomodoroSessionHistoryByDate(Long userId,
        LocalDate date) {
        User user = userService.getUserById(userId);
        List<PomodoroSessionHistory> histories = pomodoroSessionHistoryRepository
            .findByUserAndRoutineDateOrderByStartedAtDesc(user, date);

        return histories.stream()
            .map(PomodoroSessionHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    public List<PomodoroSessionHistoryDto> getPomodoroSessionHistoryByRoutineId(Long routineId,
        LocalDate date) {
        List<PomodoroSessionHistory> histories = pomodoroSessionHistoryRepository
            .findByOriginalRoutineIdAndRoutineDate(routineId, date);

        return histories.stream()
            .map(PomodoroSessionHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    // ÎÇ†Ïßú Î≤îÏúÑÏùò ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå
    public List<RoutineHistoryDto> getHistoryByDateRange(Long userId, LocalDate startDate,
        LocalDate endDate) {
        User user = userService.getUserById(userId);
        List<RoutineHistory> histories = routineHistoryRepository.findByUserAndDateRange(user,
            startDate, endDate);

        return histories.stream()
            .map(RoutineHistoryDto::fromEntity)
            .collect(Collectors.toList());
    }

    @Transactional
    public void archiveRoutinesAndCreateNew(LocalDate targetDate) {
        log.info("Starting routine archiving process for date: {}", targetDate);

        List<DailyRoutine> allRoutines = dailyRoutineRepository.findAllWithUser()
            .stream()
            .filter(routine -> !routine.getIsDeleted())
            .collect(Collectors.toList());

        log.info("Found {} routines to archive", allRoutines.size());

        for (DailyRoutine routine : allRoutines) {
            try {
                User user = userService.getUserById(routine.getUser().getId());
                Long routineId = routine.getId();

                // üîß 1. Î®ºÏ†Ä Ìè¨Î™®ÎèÑÎ°ú ÏÑ∏ÏÖò ÏÇ≠Ï†ú (FK Ï†úÏïΩÏ°∞Í±¥ Ìï¥Í≤∞)
                archivePomodoroSessions(routine, targetDate);

                // üîß 2. Í¥ÄÎ†®Îêú Î™®Îì† ÏûêÏãù Îç∞Ïù¥ÌÑ∞Îì§ÏùÑ ÌûàÏä§ÌÜ†Î¶¨Î°ú Ïù¥Í¥Ä
                archiveReviewData(routine, user, targetDate);

                // üîß 3. Î£®Ìã¥ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•
                RoutineHistory history = createRoutineHistory(routine, user, targetDate);
                routineHistoryRepository.save(history);
                log.debug("Archived routine ID {} for user {}", routineId, user.getId());

                // üîß 4. ÏÉàÎ°úÏö¥ Î£®Ìã¥ ÏÉùÏÑ±
                DailyRoutine newRoutine = DailyRoutine.builder()
                    .user(user)
                    .category(routine.getCategory())
                    .title(routine.getTitle())
                    .description(routine.getDescription())
                    .focusTime(routine.getFocusTime())
                    .breakTime(routine.getBreakTime())
                    .status("ACTIVE")
                    .actualFocusTime(0)
                    .startedAt(null)
                    .completedAt(null)
                    .isDeleted(false)
                    .build();
                dailyRoutineRepository.save(newRoutine);

                // üîß 5. ÎßàÏßÄÎßâÏóê Í∏∞Ï°¥ Î£®Ìã¥ ÏÇ≠Ï†ú (Ïù¥Ï†ú FK Ï†úÏïΩÏ°∞Í±¥ ÏóêÎü¨ ÏóÜÏùå!)
                dailyRoutineRepository.delete(routine);
                log.debug("Created new routine for user {}", user.getId());

            } catch (Exception e) {
                log.error("Error archiving routine ID {} for user {}: {}",
                    routine.getId(), routine.getUser().getId(), e.getMessage());
                throw new RuntimeException("Failed to archive routine: " + routine.getId(), e);
            }
        }

        log.info("Completed routine archiving process for date: {}", targetDate);
    }

    private void archiveReviewData(DailyRoutine routine, User user, LocalDate targetDate) {
        Long routineId = routine.getId();

        try {
            // ÏΩîÎî©ÌÖåÏä§Ìä∏ Î¶¨Î∑∞Î•º ÌûàÏä§ÌÜ†Î¶¨Î°ú Ïù¥Í¥Ä
            List<CodingTestReview> codingTestReviews = codingTestReviewRepository
                .findByRoutineAndIsDeletedFalse(routine);

            for (CodingTestReview review : codingTestReviews) {
                CodingTestReviewHistory history = CodingTestReviewHistory
                    .fromCodingTestReview(review, user, targetDate);
                codingTestReviewHistoryRepository.save(history);
            }

            if (!codingTestReviews.isEmpty()) {
                codingTestReviewRepository.deleteAll(codingTestReviews);
                log.debug("Archived {} coding test reviews for routine {}",
                    codingTestReviews.size(), routineId);
            }

            // Î©¥Ï†ë Î¶¨Î∑∞Î•º ÌûàÏä§ÌÜ†Î¶¨Î°ú Ïù¥Í¥Ä
            List<InterviewReview> interviewReviews = interviewReviewRepository
                .findByRoutineAndIsDeletedFalse(routine);

            for (InterviewReview review : interviewReviews) {
                InterviewReviewHistory history = InterviewReviewHistory
                    .fromInterviewReview(review, user, targetDate);
                interviewReviewHistoryRepository.save(history);
            }

            if (!interviewReviews.isEmpty()) {
                interviewReviewRepository.deleteAll(interviewReviews);
                log.debug("Archived {} interview reviews for routine {}", interviewReviews.size(),
                    routineId);
            }

        } catch (Exception e) {
            log.error("Error archiving review data for routine {}: {}", routineId, e.getMessage());
            throw e;
        }
    }

    private void archivePomodoroSessions(DailyRoutine routine, LocalDate targetDate) {
        try {
            User user = routine.getUser();

            // üîß 1. Î®ºÏ†Ä Ïó¥Î¶∞ ÏÑ∏ÏÖòÎì§ÏùÑ Îã´Í∏∞
            List<PomodoroSession> openSessions = pomodoroSessionRepository
                .findByRoutineAndEndedAtIsNull(routine);

            for (PomodoroSession session : openSessions) {
                PomodoroSession closedSession = PomodoroSession.builder()
                    .id(session.getId())
                    .routine(session.getRoutine())
                    .durationMinutes(session.getDurationMinutes())
                    .startedAt(session.getStartedAt())
                    .endedAt(targetDate.atTime(23, 59, 59))
                    .build();
                pomodoroSessionRepository.save(closedSession);
            }

            if (!openSessions.isEmpty()) {
                log.debug("Closed {} open pomodoro sessions for routine {}", openSessions.size(),
                    routine.getId());
            }

            // üîß 2. Ìï¥Îãπ Î£®Ìã¥Ïùò Î™®Îì† Ìè¨Î™®ÎèÑÎ°ú ÏÑ∏ÏÖòÏùÑ ÌûàÏä§ÌÜ†Î¶¨Î°ú Ïù¥Í¥Ä
            List<PomodoroSession> allSessions = pomodoroSessionRepository
                .findByRoutineIdOrderByStartedAtDesc(routine.getId());

            if (!allSessions.isEmpty()) {
                // ÌûàÏä§ÌÜ†Î¶¨ ÌÖåÏù¥Î∏îÎ°ú Îç∞Ïù¥ÌÑ∞ Ïù¥Í¥Ä
                for (PomodoroSession session : allSessions) {
                    PomodoroSessionHistory history = PomodoroSessionHistory
                        .fromPomodoroSession(session, user, targetDate);
                    pomodoroSessionHistoryRepository.save(history);
                }

                // ÏõêÎ≥∏ ÏÑ∏ÏÖò ÏÇ≠Ï†ú
                pomodoroSessionRepository.deleteAll(allSessions);

                log.debug("Archived {} pomodoro sessions to history for routine {}",
                    allSessions.size(), routine.getId());
            }

        } catch (Exception e) {
            log.error("Error archiving pomodoro sessions for routine {}: {}", routine.getId(),
                e.getMessage());
            throw e;
        }
    }

    private RoutineHistory createRoutineHistory(DailyRoutine routine, User user,
        LocalDate targetDate) {
        return RoutineHistory.builder()
            .user(user)
            .originalRoutineId(routine.getId())
            .category(routine.getCategory())
            .title(routine.getTitle())
            .description(routine.getDescription())
            .status(routine.getStatus())
            .focusTime(routine.getFocusTime())
            .actualFocusTime(routine.getActualFocusTime())
            .breakTime(routine.getBreakTime())
            .startedAt(routine.getStartedAt())
            .completedAt(routine.getCompletedAt())
            .routineDate(targetDate)
            .createdAt(routine.getCreatedAt())
            .build();
    }

    // ÌäπÏ†ï ÏÇ¨Ïö©ÏûêÏùò Î£®Ìã¥ ÌÜµÍ≥Ñ Ï°∞Ìöå
    public Object getRoutineStats(Long userId) {
        User user = userService.getUserById(userId);
        return routineHistoryRepository.getStatsByCategory(user);
    }

    // Ìè¨Î™®ÎèÑÎ°ú ÏÑ∏ÏÖò ÌûàÏä§ÌÜ†Î¶¨ Í∏∞Î∞ò ÌÜµÍ≥Ñ Ï°∞Ìöå Î©îÏÑúÎìúÎì§
    public Integer getTotalFocusTimeFromHistory(Long userId) {
        User user = userService.getUserById(userId);
        return pomodoroSessionHistoryRepository.getTotalCompletedMinutesByUser(user);
    }

    public List<Object[]> getDailyFocusTimeFromHistory(Long userId) {
        User user = userService.getUserById(userId);
        return pomodoroSessionHistoryRepository.getDailyFocusTimeByUser(user);
    }

    public List<Object[]> getMonthlyFocusTimeFromHistory(Long userId) {
        User user = userService.getUserById(userId);
        return pomodoroSessionHistoryRepository.getMonthlyFocusTimeByUser(user);
    }

    public List<Object[]> getWeeklyAverageFocusTimeFromHistory(Long userId) {
        return pomodoroSessionHistoryRepository.getWeeklyAverageFocusTimeByUser(userId);
    }

    public List<Object[]> getFocusTimeStatsByCategory(Long userId) {
        User user = userService.getUserById(userId);
        return pomodoroSessionHistoryRepository.getFocusTimeStatsByCategory(user);
    }

    public List<Object[]> getCompletionRate(Long userId) {
        User user = userService.getUserById(userId);
        return pomodoroSessionHistoryRepository.getCompletionRateByUser(user);
    }

    // Ïò§ÎûòÎêú ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ (Ïòà: 6Í∞úÏõî Ïù¥Ï†Ñ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú)
    @Transactional
    public void cleanupOldHistories(int monthsToKeep) {
        LocalDate cutoffDate = LocalDate.now().minusMonths(monthsToKeep);

        // Î£®Ìã¥ ÌûàÏä§ÌÜ†Î¶¨ Ï†ïÎ¶¨
        routineHistoryRepository.deleteOldHistories(cutoffDate);

        // Ìè¨Î™®ÎèÑÎ°ú ÏÑ∏ÏÖò ÌûàÏä§ÌÜ†Î¶¨ Ï†ïÎ¶¨
        pomodoroSessionHistoryRepository.deleteOldHistories(cutoffDate);

        log.info("Cleaned up history data older than {}", cutoffDate);
    }

    @Transactional
    public void checkAndArchiveIfNeeded(LocalDate targetDate) {
        log.info("Checking archive status for date: {}", targetDate);

        // Ïò§Îäò ÎÇ†ÏßúÎùºÎ©¥ ÏïÑÏπ¥Ïù¥Î∏åÌïòÏßÄ ÏïäÏùå
        if (targetDate.equals(LocalDate.now())) {
            log.info("Target date is today, skipping archive");
            return;
        }

        // ÎØ∏Îûò ÎÇ†ÏßúÎùºÎ©¥ ÏïÑÏπ¥Ïù¥Î∏åÌïòÏßÄ ÏïäÏùå
        if (targetDate.isAfter(LocalDate.now())) {
            log.info("Target date is in the future, skipping archive");
            return;
        }

        // Ìï¥Îãπ ÎÇ†ÏßúÏùò ÌûàÏä§ÌÜ†Î¶¨Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
        List<RoutineHistory> allHistoriesForDate = routineHistoryRepository.findAll()
            .stream()
            .filter(h -> h.getRoutineDate().equals(targetDate))
            .collect(Collectors.toList());

        List<DailyRoutine> allActiveRoutines = dailyRoutineRepository.findAllWithUser()
            .stream()
            .filter(r -> !r.getIsDeleted())
            .collect(Collectors.toList());

        if (allHistoriesForDate.isEmpty() && !allActiveRoutines.isEmpty()) {
            log.info("No history found for date {} but active routines exist. Starting archive...",
                targetDate);
            archiveRoutinesAndCreateNew(targetDate);
        } else if (!allHistoriesForDate.isEmpty()) {
            log.info("History already exists for date: {}", targetDate);
        } else {
            log.info("No routines to archive for date: {}", targetDate);
        }
    }
}